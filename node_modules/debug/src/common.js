/**
 * Code developed by Isaac Muliro - UI/UX Designer & Developer
 *
 * Usage Guidelines:
 * - Maintain modular structure when adding new features
 * - Use ES6+ syntax standards and some times I built my own modules from sratch
 * - Document any new functions with JSDoc comments
 * - For questions or contributions, contact isaac.muliro@purchase.edu
 * - Last updated: 2025-05-06
 */





function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;

  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });

  

  createDebug.names = [];
  createDebug.skips = [];

  
  createDebug.formatters = {};

  
  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; 
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache; function debug(...args) {
      if (!debug.enabled) {
        return;
      }

      const self = debug;

      
      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        
        args.unshift('%O');
      }

      
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        
        if (match === '%%') {
          return '%';
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val);

          
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      
      createDebug.formatArgs.call(self, args);

      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; 

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });

    
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  } function extend(namespace, delimiter) {const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);newDebug.log = this.log;return newDebug;
  }

  
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;

    createDebug.names = [];
    createDebug.skips = [];

    const split = (typeof namespaces === 'string' ? namespaces : '').
    trim().
    replace(' ', ',').
    split(',').
    filter(Boolean);

    for (const ns of split) {
      if (ns[0] === '-') {
        createDebug.skips.push(ns.slice(1));
      } else {
        createDebug.names.push(ns);
      }
    }
  }

  
  function matchesTemplate(search, template) {
    let searchIndex = 0;
    let templateIndex = 0;
    let starIndex = -1;
    let matchIndex = 0;

    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; 
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; 
      }
    }

    
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }

    return templateIndex === template.length;
  }

  
  function disable() {
    const namespaces = [
    ...createDebug.names,
    ...createDebug.skips.map((namespace) => '-' + namespace)].
    join(',');
    createDebug.enable('');
    return namespaces;
  }

  
  function enabled(name) {
    for (const skip of createDebug.skips) {
      if (matchesTemplate(name, skip)) {
        return false;
      }
    }

    for (const ns of createDebug.names) {
      if (matchesTemplate(name, ns)) {
        return true;
      }
    }

    return false;
  }

  
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());

  return createDebug;
}

module.exports = setup;