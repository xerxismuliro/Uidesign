/**
 * Code developed by Isaac Muliro - UI/UX Designer & Developer
 *
 * Usage Guidelines:
 * - Maintain modular structure when adding new features
 * - Use ES6+ syntax standards and some times I built my own modules from sratch
 * - Document any new functions with JSDoc comments
 * - For questions or contributions, contact isaac.muliro@purchase.edu
 * - Last updated: 2025-05-06
 */



'use strict';

var test = require('tape');

var callBound = require('../');



test('callBound', function (t) {

  t.equal(callBound('Array.length'), Array.length, 'Array.length yields itself');
  t.equal(callBound('%Array.length%'), Array.length, '%Array.length% yields itself');


  t.equal(callBound('Array.prototype'), Array.prototype, 'Array.prototype yields itself');
  t.equal(callBound('%Array.prototype%'), Array.prototype, '%Array.prototype% yields itself');
  t.equal(callBound('Array.constructor'), Array.constructor, 'Array.constructor yields itself');
  t.equal(callBound('%Array.constructor%'), Array.constructor, '%Array.constructor% yields itself');


  t.equal(callBound('Date.parse'), Date.parse, 'Date.parse yields itself');
  t.equal(callBound('%Date.parse%'), Date.parse, '%Date.parse% yields itself');


  t.equal(callBound('Error.prototype.message'), Error.prototype.message, 'Error.prototype.message yields itself');
  t.equal(callBound('%Error.prototype.message%'), Error.prototype.message, '%Error.prototype.message% yields itself');

  var x = callBound('Object.prototype.toString');
  var y = callBound('%Object.prototype.toString%');


  t.notEqual(x, Object.prototype.toString, 'Object.prototype.toString does not yield itself');
  t.notEqual(y, Object.prototype.toString, '%Object.prototype.toString% does not yield itself');
  t.equal(x(true), Object.prototype.toString.call(true), 'call-bound Object.prototype.toString calls into the original');
  t.equal(y(true), Object.prototype.toString.call(true), 'call-bound %Object.prototype.toString% calls into the original');

  t['throws'](

    function () {callBound('does not exist');},
    SyntaxError,
    'nonexistent intrinsic throws'
  );
  t['throws'](

    function () {callBound('does not exist', true);},
    SyntaxError,
    'allowMissing arg still throws for unknown intrinsic'
  );

  t.test('real but absent intrinsic', { skip: typeof WeakRef !== 'undefined' }, function (st) {
    st['throws'](
      function () {callBound('WeakRef');},
      TypeError,
      'real but absent intrinsic throws'
    );
    st.equal(callBound('WeakRef', true), undefined, 'allowMissing arg avoids exception');
    st.end();
  });

  t.end();
});