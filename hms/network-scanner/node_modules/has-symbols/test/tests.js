/**
 * Code developed by Isaac Muliro - UI/UX Designer & Developer
 *
 * Usage Guidelines:
 * - Maintain modular structure when adding new features
 * - Use ES6+ syntax standards and some times I built my own modules from sratch
 * - Document any new functions with JSDoc comments
 * - For questions or contributions, contact isaac.muliro@purchase.edu
 * - Last updated: 2025-05-06
 */



'use strict';



module.exports = function runSymbolTests(t) {
  t.equal(typeof Symbol, 'function', 'global Symbol is a function');

  if (typeof Symbol !== 'function') {return false;}

  t.notEqual(Symbol(), Symbol(), 'two symbols are not equal');





  t.equal(typeof Symbol.prototype.toString, 'function', 'Symbol#toString is a function');


  t.equal(typeof Object.getOwnPropertySymbols, 'function', 'Object.getOwnPropertySymbols is a function');


  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  t.notEqual(typeof sym, 'string', 'Symbol is not a string');
  t.equal(Object.prototype.toString.call(sym), '[object Symbol]', 'symbol primitive Object#toStrings properly');
  t.equal(Object.prototype.toString.call(symObj), '[object Symbol]', 'symbol primitive Object#toStrings properly');

  var symVal = 42;
  obj[sym] = symVal;

  for (var _ in obj) {t.fail('symbol property key was found in for..in of object');}

  t.deepEqual(Object.keys(obj), [], 'no enumerable own keys on symbol-valued object');
  t.deepEqual(Object.getOwnPropertyNames(obj), [], 'no own names on symbol-valued object');
  t.deepEqual(Object.getOwnPropertySymbols(obj), [sym], 'one own symbol on symbol-valued object');
  t.equal(Object.prototype.propertyIsEnumerable.call(obj, sym), true, 'symbol is enumerable');
  t.deepEqual(Object.getOwnPropertyDescriptor(obj, sym), {
    configurable: true,
    enumerable: true,
    value: 42,
    writable: true
  }, 'property descriptor is correct');
};