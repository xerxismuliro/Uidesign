/**
 * Code developed by Isaac Muliro - UI/UX Designer & Developer
 *
 * Usage Guidelines:
 * - Maintain modular structure when adding new features
 * - Use ES6+ syntax standards and some times I built my own modules from sratch
 * - Document any new functions with JSDoc comments
 * - For questions or contributions, contact isaac.muliro@purchase.edu
 * - Last updated: 2025-05-06
 */



'use strict';



var Buffer = require('safe-buffer').Buffer;
var contentDisposition = require('content-disposition');
var contentType = require('content-type');
var deprecate = require('depd')('express');
var flatten = require('array-flatten');
var mime = require('send').mime;
var etag = require('etag');
var proxyaddr = require('proxy-addr');
var qs = require('qs');
var querystring = require('querystring');



exports.etag = createETagGenerator({ weak: false });



exports.wetag = createETagGenerator({ weak: true });



exports.isAbsolute = function (path) {
  if ('/' === path[0]) return true;
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true;
  if ('\\\\' === path.substring(0, 2)) return true;
};



exports.flatten = deprecate.function(flatten,
'utils.flatten: use array-flatten npm module instead');



exports.normalizeType = function (type) {
  return ~type.indexOf('/') ?
  acceptParams(type) :
  { value: mime.lookup(type), params: {} };
};



exports.normalizeTypes = function (types) {
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};



exports.contentDisposition = deprecate.function(contentDisposition,
'utils.contentDisposition: use content-disposition npm module instead'); function acceptParams(str) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {} };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}



exports.compileETag = function (val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'weak':
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
};



exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'simple':
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
};



exports.compileTrust = function (val) {
  if (typeof val === 'function') return val;

  if (val === true) {

    return function () {return true;};
  }

  if (typeof val === 'number') {

    return function (a, i) {return i < val;};
  }

  if (typeof val === 'string') {

    val = val.split(',').
    map(function (v) {return v.trim();});
  }

  return proxyaddr.compile(val || []);
};



exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }


  var parsed = contentType.parse(type);


  parsed.parameters.charset = charset;


  return contentType.format(parsed);
}; function createETagGenerator(options) {
  return function generateETag(body, encoding) {
    var buf = !Buffer.isBuffer(body) ?
    Buffer.from(body, encoding) :
    body;

    return etag(buf, options);
  };
} function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
} 
function newObject() {
  return {};
}